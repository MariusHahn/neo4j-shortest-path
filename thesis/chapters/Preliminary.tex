\chapter{Preliminaries}

As the target platform for this work is the graph to database Neo4j, we will mostly consider \textit{directed} graphs.
From the terminology we always refer \textit{arcs}, which is an directed edge.
In some cases we will refer to \textit{edges}, in these cases the direction irrelevant.

\section{Notation and Expressions}
We denote a graph $G(V, A)$ in case we mean a \textit{directed} graph, where $v$ is a vertex contained in the vertices $v \epsilon  V$ and $a$ is an arc $a \epsilon A$.
An arc is uniquely defined by vertices $v_a$ and $v_b$ such that $v_a \neq v_b$, so there are neither loops nor multi edges.
An arc has a weight function $w: A \rightarrow \mathbb{R}_{<0} $ that returns a positive integer.
\\
We use $A$ as the arc set and $a$ for a single directed arc.
$a \epsilon A$ can be replace with $e \epsilon E$ which refers to edges that are \textit{undirected}. 
\\
$G$ represents the input graph.
The index graph $G'(V', A')$ is the graph which will be used at contraction for initially building the CCH index structure.
A vertex $v$ in will never be actually deleted.
Instead the rank property is set to mark this vertex as contracted.
So $V \equiv V'$ but $A \subseteq A'$ as arcs are added during the contraction.
$S = A' \setminus A$ is the shortcut set that is added.
\\
We define the set of neighbors as $N(v)$, as vertices which are connected to $v$ with an arc. 
If we only want to get the neighbors of higher rank we will use $N_\uparrow(v)$.
Analogously $N_\downarrow(v)$ defines the neighborhood of vertex $v$ which is of lower rank.
\\
We define the degree of a vertex $v$ as the number of neighbors this vertex has $|N(v)|$. 
The overall degree is the sum of a all upwards and downwards neighbors $|N(v)| = N_\uparrow(v) + N_\downarrow(v)$.
\\
It exists a function on each graph $v : G \rightarrow \mathbb{N}_0$ that receives a positive integer and returns the vertex which has this rank assigned.
\\
$G^*(V^*, A^*)$ is the search graph when calculating a shortest path query.
Futhermore one query will have two search graphs.
$G^*_\uparrow$ representing the upwards search graph and the $G^*_\downarrow$ representing the downwards search graph.
\\
Finally there will be the edge set of edges that are written onto the disk.
These $\bigcirc A$ will be separated into sets $\bigcirc A_\downarrow$ and $\bigcirc A_\uparrow $, too.

\section{Priority Queue}

One data structure that is heavily used in this paper is a priority queue.
This a very useful structure as it always returns the element with the lowest priority.
In Dijkstra's algorithm for example, the priority is calculated on the path weight, thus retrieving an DijkstraState one will always get smallest remaining.
A problem arises when updating an element of a priority queue that is already in the queue, because a priority queue can contain the same element multiple times, even with different priorities.
The following explanation refers to the Java 17 reference \cite{JavaPrioQueue}, but priority queues which are based on a binary heap \cite{floyd1964algorithm} all have the same properties.
\\
One might ask why it is impossible remove the element that is already in the queue and then re-push it.
That is possible but slow, as the operations \textit{contains(element)}, and \textit{remove(element)} are running in linear time $\mathcal{O}(n) $.
It would be better to use \textit{offer(), poll(), remove()} or \textit{add()} which run in logarithmic time $\mathcal{O}( \log (n))$.
One possible could be to keep a reference to the element and change the priority as needed at a later point.
But the queue will not be notified by such a manipulation, and because the queue eagerly keeps the next element to dequeue at the top one will retrieve the wrong element.
So we have to come up with something better.
It does not cause a problem if the priority of an element only decreases, as by doing so one will always certainly receive the one with the lowest priority.
Therefore one can re-push elements to the queue, as one will always remove the smallest element from the head.
To avoid processing an element twice one inserts the elements into a set where one keep track of the already processed elements and if one retrieve an already seen element one poll again.
If the priority can decrease and increase and one push updated the elements to again, the problem is a bit more difficult as now one can possibly dequeue an element with the old priority which is lower as the current but not valid anymore.
We create a priority queue and a hash table whose key is the element and the value is a integer a version number.
If we push an element to the queue we check whether the element is already in the control hash table, if not not we insert it together with the value $0$.
Then we wrap the element together with the $0$ and insert it into the queue.
If the element is already in the control hash table we increase its version number in the hash table by one, wrap this new version's number together with the element and push it into the queue.
At poll we retrieve the element together with its current version number.
If the number is not equal to the one in the control hash table we poll again and check until we find an element that is up to date. 
As a result we can keep $\mathcal{O}( \log (n))$, because \textit{put(key, value)} and {get(key)} run in constant time in hash table given there is a suitable hash function.

\section{Dijkstra' algorithm} \label{sec:dijkstra}

\begin{figure}
    \centering
    \input{assets/uml/dijkstra.tex}
    \caption{Dijkstra Class Diagram}
    \label{fig:dijkstra_class}
\end{figure}

Here, we want to explain Dijkstra's algorithm as it is crucial for the ch/cch search.
Additionally we want to decouple two things which are usually done together.
The initialization of a dijkstra query and the iteration step, which expands vertices until the shortest path is found.
\\ 
Dijkstra finds the shortest path from a source vertex to a target vertex by always using the \textit{best} path. 
\textit{Best} means the path that has the shortest distance to the start.
Dijkstra starts with expanding the neighborhood of the source vertex and will move on to the vertex that has the smallest total distance to the source vertex.
This is done until dijkstra is about to expand the target node int the next step.
In the process of finding the target, dijkstra also finds the shortest path to every node it expands.
Therefore dijkstra cannot only be used to do \textit{one to one} shortest path queries, but also for \textit{one to many} and \textit{one to all} shortest path queries.
\\
Looking at Figure \ref{fig:dijkstra_class} we initialize the query with a start ID, a set of target IDs and the graph on which we will use for to do the query.
During the construction process the query will take the start ID, create an object of the type \textit{DijkstraState} and push it to the \textit{queue}.
This priority queue is organized by the path weight of \textit{DijkstraState} such that one always polls the shortest path that is inside the queue.
\\
After the initialization, we can start expanding nodes by using the \textit{expandNext()} method, which we provided in Algorithm \ref{alg:disjkstra_algorithm}.
Firstly we poll the next state from the queue.
Then we check whether the endVertex of the just retrieved state is in set of targets we are looking for or the set of goals is empty; meaning we will do a \textit{one to all} search.
If so we add the just found shortest path to the \textit{shortestPaths} and settle it as we know that we found the shortest path for that endVertex.
We iterate over the arcs which are attached to this endVertex and therefore get its neighbors.
Afterwards for each neighbor we check if we have to update it with a new state in the queue.
This is the case if either we have not seen this vertex so far or the state in the queue is of higher weight as the one we just found.
\input{assets/pseudocode/dijkstra.tex}
\\
The \textit{expandNext()} procedure is usually done in a while loop until the \textit{isComplete()} function returns \textit{true} and all requested shortest paths are found or all vertices have been expanded.
We provide this with the function \textit{getResult()} on a dijkstra query object as one can see in Figure \ref{fig:dijkstra_class}.
Being able to call the \textit{expandNext()} procedure from outside is very powerful.
For example if we want to write a bidirectional dijkstra, we can create two instances of the class \textit{Dijkstra} as stated in Figure \ref{fig:dijkstra_class}.
One dijkstra is initialized only with outgoing $\text{Dijkstra(}s, [t,], \overrightarrow{G}(V, \overrightarrow{A}) \text{)}$ arcs the other only with incoming arcs $\text{Dijkstra(}t, [s], \overleftarrow{G}(V, \overleftarrow{A}) \text{)}$.
This framework we can use to build our algorithm which tells the bidirectional query when to stop or which side to expand next. 
The essential finding is that we have reused the logic of the \textit{expandNext()} procedure and not written it again.

\section{Contraction Hierarchies}

Contraction Hierarchies \cite{Sanders} is a method which first augments the graph with some additional edges that later on help Dijkstra's algorithm, such that it needs to expand fewer vertices.

\begin{figure}[H]
    \centering
    \input{assets/tikz/chsimple.tex}
    \caption{Contraction Hierarchies simple example}
    \label{fig:ch_simple_example}
\end{figure}

Reading Figure \ref{fig:ch_simple_example} Contraction Hierarchies contracts or deletes vertices in a given order. 
The order we take is defined by the number one sees inside the vertices: CH contracts it in this order $v(1)$, $v(2)$, $v(3)$ and finally $v(4)$.
Only the solid lines are edges of the original graph.
The dashed line is a shortcut.
While contracting vertices it preserves the shortest path among the remaining vertices.
At first $v(1)$ is contracted and as $v(1)$ is on the shortest path between $v(2)$ and $v(3)$ a shortcut is inserted between them.
This is the only shortcut CH inserts in this small graph.
In a shortest path dijkstra will now be restricted to only expand edges which are of higher rank.
To include all possible path CH does this from the source vertex side expanding all outgoing edges and from the target side with all ingoing edges.
If we want to find the shortest path from $v(2)$ to $v(3)$, CH will expand all outgoing of $v(2)$ where it finds $v(3)$.
It also expands all ingoing of the target vertex $v(3)$ where it finds $v(4)$. 
Then both search side are merged at the meeting point which is in this case $v(4)$.
This results in the path on the right in Figure \ref{fig:ch_simple_example}. 
The upwards search also find the a direct path from $v(2)$ to $v(3)$, which one can see in the middle of Figure \ref{fig:ch_simple_example}. 
Out of all these paths one take the shortest, which is also the shortest path in the original graph.
A shortcut does not only contain a weight information but also which vertex was contracted as it was inserted.
With this information one can resolve the actual path in the graph.