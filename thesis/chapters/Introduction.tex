\chapter{Introduction}

Most applications which handle data have to store these eventually.
Simple files do not offer enough semantic structure.
Therefore databases have been developed to not only store but query and aggregate data effectively and efficiently.
Relational databases that store data in tables have become the unspoken industry standard in the last decades. 
However there are domains that do not naturally fit into tables and one will need a lot of restructuring to make them fit.
As a result, there have been efforts to create databases that use other abstractions to store data, like the graph database Neo4j.

\section{Background and Motivation}

In a relational database the data is organized in tables.
Tables have rows and theses rows can be connected to other rows of the same or a different table using joins on matching cells, usually primary- foreign key relationships.
To retrieve information that is stored in two table rows one has to scan both an join them on the desired key property.
Depending on the size of the tables and the number of joins which have to be done to retrieve the desired information, such queries can be very expensive.
\\
In contrast to relational databases, graph databases treat relationships as first-class citizen.
This means a relationship that connects nodes is an entity just as the nodes it connects themselves.
As in a graph database, a node has a pointer to its relationship and a relationship has a pointer to its nodes, there is no table scan needed to retrieve connected data, which can make these queries very performant.
Such queries are shortest path queries on domains which resembles a graph by their nature, for instance road networks. 

\section{Problem and Objectives}

We focus on these shortest path queries and try to make these even quicker by employing an index call Customization Contraction Hierarchies \cite{CCH}, \textit{CCH}. 
CCH is proven to achieve a tremendous speedup compared to Dijkstra's algorithm in graphs where one can find vertices that are more important than others.
Important in this context means that these vertices belong to many shortest paths.
One example for such a domain are road networks, which we will also use in our test scenarios.

\section{Contribution}

In comparison to many other papers that examine CCH in their specific details we want to examine if we can adopt it to the graph database Neo4j, and still keep its advantages.
Will we be able to store the index in a manner which allows us to keep the performance gain we had achieved before?
Additionally we want to explore how the index behaves after updating multiple edge weights.
Will queries still be as quick as they were before the update?
This is an essential question as data in databases are usually not only stored but also manipulated.
We also want to uncover how big such an index graph will become, as there might be no need to read the index from the disk, because it easily fits in main memory.
\\
Finally we want to keep the integration into Neo4j as small as possible to make it as easy as possible at a later point to port the implementation to other graph databases that might become more relevant in future.
