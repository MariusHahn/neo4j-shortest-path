\chapter{Related Work} 

As our research focus is set ti databases, we want to divide this chapter in two main sections \nameref{sec:algorithmic_history} and \nameref{sec:related_work:database}.
\nameref{sec:algorithmic_history} that will give some basic overview what has been published regarding index structures to speed up shortest path queries for graphs.
\nameref{sec:related_work:database} we will try to give an overview of efforts that have been made to make \cite[Customizable Contraction Hierarchies]{CCH} it suitable for graph databases.

\section[Algorithmic History]{Algorithmic History} \label{sec:algorithmic_history}

The basic algorithm to answer shortest path queries is \cite[dijkstra]{Dijkstra_1959}.
It is from 1959 and in the decades after it there have been many approaches to get it quicker.
To name some there is \cite[A*]{A_Star}, which adds a heuristic to each node to help dijkstra to go in the right direct.
Then there is \cite[ALT]{ALT} with stands for \textit{A* + Landmarks + Triangle Inequality}, which is a approach to improve the A* heuristic with landmarks.
Then there is the \cite[Arc Flag]{ARC_FLAG} approach that which is based on the idea that many shortest paths in a graph usually overlap, so we can store them in a compact way.
Later only edges which are flagged true for the target direction will be expanded by dijkstra.
Then there is the \cite[Transit-Node]{Bast_2007} that makes use of the observation that if you want to go far, nodes that are spacial close usually pass by the same node.
One will try to find such nodes and store their connecting shortest paths in a table.
If one looks for the way from one to another node one only starts to local dijkstra for the source and the target side until one finds a transit node.
As the distance between the transit nodes are known, we simply can look up the rest of the path.
Then there is \cite[Contraction Hierarchies]{Geisberger_2012} or CH which is the base for what we will examine further.
As transit nodes, CH goes with the idea that there are nodes that are more important than others, but instead of selecting some important nodes one ranks them all.
CCH, what we will implement for Neo4J, is a fashion of CH that makes it easier to react to changes in the CH index structure.
CH goes back to the diploma thesis of \cite[Geisberger]{Geisberger} in 2008.
As all previous mentioned techniques, CH and CCH especially speed up long distance queries.
\\ 
CH deletes nodes and inserts edges to the graph, so called shortcuts, that preserve the shortest path property in case a node that is deleted resides on a shortest path between remaining ones.
When querying a shortest path, CH uses a modified bidirectional-dijkstra that is restricted to only visit nodes that are of higher importance, called rank, than the its about to expand next.
This method is able to retrieve shortest paths of vertices that have a high spacial distance.
However, it is rather static.
In case a new edge is added or an edge weight is updated, it might be necessary to recontract the whole graph to preserve the shortest path property.
\\
In 2016 \cite[Customization Contraction Hierarchies]{CCH} or CCH was published.
The approach is the same, but in CCH shortcuts are not only added if the contraction violates the shortest path property.
Shortcuts are added if there had been a connection between its neighbors through the just contracted vertex and these neighbors do not own a direct connection through an already existing edge.
The shortcut weights are later on calculated through the lowers triangle.
Additionally \cite[Customization Contraction Hierarchies]{CCH} provides an update approach that only updates,
edges that are affected by a weight change.


\section{Neo4j Shortest Path Queries}

Neo4j contains a implementation of dijksta, bidirectional dijksta and an A* implementation out of the box.
They are provided by the traversal API, such that every plugin can use it.
Sadly the only provide a \textit{one to one} dijksta, which made it useless for our purpose.
Additionally the tests that prove our dijkstra implementation as stated in \ref{sec:dijkstra}, uses the neo4j bidirectional dijkstra and compares the path weights.
By that we also measure the time both need to find the shortest path.
It shows our unidirectional dijkstra is slightly faster than the one of neo4j.
\\
Then there is the neo4j graph data science library  which provides a \textit{one to all} and \textit{one to one} dijkstra implementation.
Additionally it contains also a A* implementation, a \textit{Yenâ€™s Shortest Path} algorithm and a \textit{Delta-Stepping Single-Source Shortest Path} algorithm.
We did't use these neither as it turned out, having our own dijkstra is key to get the implementation we are looking for.

\section{Contraction Hierarchies in Neo4j}\label{sec:related_work:database}

There is one bachelor thesis by Nicolai D'Effremo \cite[Some text]{DEffremo2019} that has implemented a version on \cite[Contraction Hierarchies]{Geisberger_2012} for Neo4j.
This implementation shows that even for databases CH is an index structure worth pursuing, as there was a tremendous speedup of shortest path queries paired with a reasonable preprocessing time.
\cite{Zickenberg2021} showed in his bachelor thesis that it is even possible to restricted these queries with label constraints.
Although CH and CCH have little difference, sadly we could not use much of the code provided by there works.
It was deeply integrated into the Neo4j-Platform.
Additionally since then two major release updates happened that have breaking changes which make it nearly impossible to reuse any of this code.
\\
Finally there is \cite[Mobile Route Planning]{Sanders} by Peter Sanders, Dominik Schultes, and Christian Vetter.
In this paper it is described how one can efficiently store the a CH index structure on a hard drive.
It states an interesting technique to how store edge that are likely to be read sequentially spatially close on the hard drive which makes read operations that have to be done during query time fast.
The motivation of \cite[Mobile Route Planning]{Sanders} through was slightly different.
They came up with this idea because computation power on mobile devices is limited, so they could precalculate the CH index on a server and then later distribute it to a mobile device.
\\
We will use parts of this idea and partly port it to our database context as we suppose there are many similarities.
