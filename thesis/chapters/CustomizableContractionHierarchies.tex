\chapter{Customizable Contraction Hierarchies}\label{sec:Preliminary_CCH}

In this section we will present the basic idea of Customization Contraction Hierarchies \cite{CCH} and also work out the main difference between CCH and Contraction Hierarchies \cite{Geisberger_2012}.
We will provide examples to help understand concepts which are crucial to comprehend our implementation.

\section{Contracting}

\input{assets/pseudocode/contraction.tex}

\begin{figure}
    \centering
    \input{assets/tikz/contractingAndSeaching.tex}
    \caption{The numbers inside the vertices represent their contraction order. Shortcuts are dashed edges}
    \label{fig:contrating_and_searching}
\end{figure}

Algorithm \ref{alg:contraction} provides our contraction algorithm.
We do a called \textit{metric dependent} contraction in Customization Contraction Hierarchies \cite{CCH}.
This is a greedy algorithm which always takes the next best vertex to contract.
Some use the simple edge difference as Contraction Hierarchies \cite{Geisberger_2012}, but we will use a more advanced technique which assigns an importance to each vertex.
This importance is further described in section \ref{sec:metric_dependent_importance}, through the equation \ref{eq:importance}.
\\
Before starting we have copied $G$ into $G'$ such that both are identical but refer to their own arc and vertex set.
The input parameter of the \textit{contractGraph()} function is the set of vertices $V$ into the index graph $G'$.
At first we calculate the so called \textit{contraction} for each vertex, which is the set of shortcut arcs which has to be inserted if that vertex is contracted next.
From this contraction object we can determine the importance of the vertex.
We push the vertex together with its importance into the queue.
The  queue is a priority queue which is organized by the importance, such that \textit{Q.poll()} will always return the vertex with the lowest importance in the queue.
As long as the queue is not empty we pull the next vertex and calculate its contraction.
We assign the rank on the current vertex, initially starting at 0, and add this information to $G$ which resides in Neo4j and increase the rank for the next vertex that will be pulled from the queue.
\\ 
Then we iterate over the shortcut set of the contraction and insert a shortcut into $G'$ where there is yet no arc between vertices.
If there is already an arc which connects the vertices of a shortcut, we update the weight of that arc.
If the shortcut weight is smaller we update the middle vertex to be able to reconstruct the actual path in the input graph $G$.
In comparison to \cite{CCH}  we merge two steps in one.
The first is adding shortcuts and the sections is basic customization, through lower triangle enumeration \ref{sec:lower_triangles}.
This is needed because at this point we already have the lower triangles at hand, this we do not need to iterate over them again to set the correct weight and middle vertex of the arcs.
Then we iterate over the neighbors of the recently contracted vertex $N_\downarrow(v) \cup N_\uparrow(v)$, recalculate the contraction of these vertices and repush their importance together with the vertex back into the queue.
This is needed because the importance of a vertex depends on its neighbors.
As the neighbors of $v$ just lost a neighbor their importance has to have changed.
After the queue is empty and the algorithm is finished, the function return the top vertex, which is the one with the highest rank.
This vertex is later on needed to store the index onto the disk.
\\
To get a contraction of a vertex we have to iterate over all connected vertices of $v$ which are not yet contracted.
We initialize  a collection of shortcuts to an empty list.
Afterwards we iterate over all incoming arcs of $v$, where the start vertex has not yet been contracted.
For each of these incoming arcs we iterate over all outgoing arcs of which the end vertex has not yet been contracted.
Then we create a shortcut container object which is inserted into the shortcut collection.
Into the shortcut we insert the incoming and the outgoing arcs.
\\
Finally we calculate the edge difference and return the vertex together with the edge difference and the shortcuts, in a \textit{Contraction} object.

\subsection{Lower Triangles} \label{sec:lower_triangles}

\begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    \input{assets/tikz/lowerTriangle.tex}
    \caption{Lower Triangle}
    \label{fig:lowerTrianle}
\end{wrapfigure}


To determine an arc weight of G' we need to look at its lower triangle as shown in Figure \ref{fig:lowerTrianle}.
This is the two loops in \textit{getContraction(v)} in Algorithm \ref{alg:contraction}.
They enumerate all lower triangles of the vertex $z$, which has a lower rank than $x$ and $y$, $r(z) < r(x) < r(y)$.
The shortcut which is created, contains the arcs $b$ and $c$.
The weight of $a$ in the $G'$ is determined by the shortest lower triangle or by the weight of the input graph.
\\
The lower triangles are important for the basic customization process but also needed for the update process.
We are interested in the arc $a$.
As shown in Figure \ref{fig:lowerTrianle} it follows:


\begin{align*}\label{eq:lower_triangle}
    a_\uparrow & = b_\downarrow + c_\uparrow    &  a_\downarrow & = b_\uparrow + c_\downarrow \\
    a(x, y) & = a(x, z) + a(z, y) & a(y, x) & = a(z, x) + a(y, z)
\end{align*}

\subsection{Contraction Example}

In Figure \ref{fig:contrating_and_searching} you can see a contracted graph $G'(V,E')$ on the left.
The solid lines represent the original edges $E$ of a graph $G$.
The dashed lines between vertices are shortcuts $S$ which have been added while creating the CCH index graph $G'(V, E')$.
The numbers inside the vertices reflect the contraction order.
Contracting a vertex means deleting it.
If a vertex which is contracted resides on a simple path between two vertices of higher rank, and there is no edge $e \epsilon E'$ between these vertices a shortcut has to be inserted.
We will now reconstruct the contraction of Figure \ref{fig:contrating_and_searching}.
At first vertex $v(1)$ is removed.
As $v(1)$ resides on a simple path between $v(3)$ and $v(5)$ and there is no edge $e(v(3), v(5)) \notin E'$. 
Hence a shortcut is added to keep the connection.
The same applies after contracting $v(2)$ for the vertices $v(4)$ and $v(5)$.
For all the other vertices we do not need to insert shortcuts.

\section{Searching}

\input{assets/pseudocode/cchSearch.tex}

Algorithm \ref{alg:cchSearch} depicts our search algorithm.
It finds the shortest path between two vertices.
As input parameter is takes two integer values, which represent the rank of the start vertex and the rank of the target vertices.
At first we create a boolean variable which helps to choose whether to continue with the forward or with the backward search.
Then we initialize one forward query which receives the start vertex as input and all upwards arcs and one backward query that receives the target vertex as input and all downward arcs.
We continue until we find the shortest path.
We definitely have found the shortest path if either both queries have expanded the top vertex with the highest rank or the next vertex to expand to in both queries is further than the shortest path merge we have seen so far.
This is the functionality of \textit{isComplete} function.
All shortest path pairs will be merged and pushed to the priority queue which is called \textit{candidates}.
It is organized by the path weight and will return the shortest path merge that has been found on \textit{candidates.peek()}.
If the search is complete we simply peek at the head of \textit{candidates} and return it as the shortest path; or none if the vertices are not connected.
\\
If the search is not complete we continue.
If \textit{pickForward} is set to \textit{true} we will continue expanding the upward forward query otherwise we will expand the backward query.
Afterwards we flip \textit{pickForward}, such that in the next iteration the respective other query will be expanded.
If the query we are about to expand already reached the top vertex we continue with next iteration step, otherwise we tell the query to expand the next vertex.
If the vertex which has been expanded last in the query also appears in the set of already expanded vertices in the other query, we merge both their paths and add them to the priority query \textit{candidates} of the shortest path pairs found so far.
As two merged shortest paths do not necessarily result in a shortest path, we still have to continue as described before.

\subsection{Example}

Regarding Figure \ref{fig:contrating_and_searching}, as we preserved all shortest paths during the contraction the shortest path can be retrieved by a bidirectional Dijkstra which is restricted such that it only expands vertices of higher rank.
Therefore if one wants to retrieve the shortest path between $v(3)$ and $v(4)$ there will be a forward search from $v(3)$ and a backward search from $v(4)$.
As we restrict theses searches to expand only vertices of higher rank, the only vertices to expand are the start and target vertex.
Both will find only one vertex $v(5)$, the highest vertex and also the meeting point.
Finding at least one meeting point in the forward and backward search means there exist a path between them.
After merging these paths at the middle vertex $v(5)$ one will obtain the shortest path.
\\
For an arbitrary contracted graph it is possible that there is more than one meeting point.
As merging two shortest paths will not necessary lead to an other shortest path, one has to merge all possible meeting points and take the path among the merged ones which has the smallest distance.
\\ 
In the example of Figure \ref{fig:contrating_and_searching}, backward and forward search both reach the top vertex, so the search can stop.

\section{Difference between CH and CCH}

The left graph in Figure \ref{fig:DifferenceCHAndCCH} has been contracted in the CH way, whereas the right is the CCH way.
We explicitly state this here because we have found a paper \cite{Ouyang_2020} which mixes up these well known names, claiming they do Contraction Hierarchies, CH, while actually doing Customizable Contraction Hierarchies CCH.
The main difference is, CH will only insert a shortcut between two vertices if the vertex that is contracted resides on the shortest path between two of its neighbors.
When vertex $v(1)$ is contracted there is no shortcut inserted as vertex $v(1)$ is not on the shortest path between $v(3)$ and $v(4)$.
\\
Whereas in the CCH case the edge weights do not play a role while contracting.
If a vertex is contracted and there is no direct connection between two of its neighbors, one has to insert a shortcut.
This gives the advantage that we can later on easily update edge weights without inserting new shortcut, as all possibly needed shortcuts already exist.

\subsection{Example} 
We will complete this example by updating the edge $e(v(2), v(4))$ which currently has the weight of $w(e)=1$ to $w(e) = 5$.
Now the vertex $v(1)$ is on the shortest path between vertex $v(2)$ and $v(3)$.

To update the CH graph we have to insert an edge between vertex $v(2)$ and $v(3)$ whereas the topological structure of the CCH remains the same, one only needs to update the weight and the middle vertex of the already give shortcut edge.

\begin{figure}
    \centering
    \input{assets/tikz/DifferenceCHAndCCH.tex}
    \caption{The left represents a CH and the right a CCH contracted graph}
    \label{fig:DifferenceCHAndCCH}
\end{figure}

\section{Metric Dependent Vertex Order}\label{sec:metric_dependent_vertex_order}
There are two ways to receive a suitable vertex order.
A so called \textit{metric independent} and a so called \textit{metric dependent} one.
The metric independent recursively looks for minimum balanced separator to determine a vertex ordering\cite{CCH}.
Although this is the superior method, it is not used in this paper. 
Writing an algorithm that calculates balanced separators is not trivial, and we are not aiming for optimizing the contraction process.

The \textit{metric dependent} order mainly uses the edge difference $ED$ to determine which vertex is to be contracted next.
The $ED$ is determined as the $|edges To Insert| - |edges To Remove|$.
The fewer edges are inserted during contraction the fewer edges will be contained by the final graph, therefore fewer edges will have to be expanded during the search.
However using only the edge differences does not  lead to desired result.
This is because during contraction there will be areas which becomes sparser than others.

There are two problems which can arise.
One is that important vertices are not contracted last.
The other is the search space of the query becomes linear although it could be logarithmic.

\subsection{Important Vertices not contracted last}\label{sec:not_contracted_last}

\begin{figure}
    \centering
    \input{assets/tikz/notContractedLast.tex}
    \caption{The numbers inside the vertices represent their contraction order}
    \label{fig:not_contracted_last}
\end{figure}

Figure \ref{fig:not_contracted_last}, this is a possible contraction order, if the $ED$ is to contract vertices.
At the beginning the vertices with rank 1, 2, 3, 5 have the same edge difference, which is $ED = -1$.
Vertex after vertex is removed  and  no shortcut is inserted.
This happens until there are only $v(4)$ and $v(5)$ left.
Now $v(4)$ has also an $ED=-1$, similar as $v(5)$.
Thus chance is $\frac{1}{2}$ the algorithm contracts $v(4)$ before $v(5)$.
This is not the desired result.
There are six \\$e(v(1),v(2)), e(v(1),v(3)), e(v(1),v(5)), e(v(2),v(3)), e(v(2),v(5)), e(v(3),v(5))$  shortest paths that involve  $v(4)$. 
All the other vertices do not encode any shortest path, therefore $v(4)$ should be contracted last.
The search graph on the right of Figure \ref{fig:not_contracted_last} shows the reason.
Imagine we we do a shortest path query between $v(1)$ and $v(3)$.
After expanding both, the forward and the backward search to $v(4)$, there is yet another vertex we will have to expand $v(5)$.
Although as visible in the original graph on the right, it is not possible that $v(5)$ is on the shortest path.
Therefore a better contraction order would be contracting $v(5)$ before $v(4)$.
This issue can be overcome by the method that is explained in section \ref{sec:vertex_importance}.

\subsection{Linear Query Search Space}\label{sec:linear_query}

\begin{figure}
\centering
\input{assets/tikz/linearContraction.tex}
\caption{Linear Contraction}
\label{fig:linear_contraction}
\end{figure}

Figure \ref{fig:linear_contraction} shows three possible index graphs $G'$ of one and the same base graph $G$.
The numbers inside the vertices represent the contraction order.
\\
The first one could be contracted using the edge difference $ED$, as always one of the outer vertices with $ED=-1$ was contracted.
On the one hand it reaches the optimum in case for \textit{least shortcuts inserted}.
On the other hand it has the worst search space among the three vertex orderings.
To get from vertex $v(1)$ to $v(5)$ we have to expand four vertices.
\\
The second $G'$ is contracted from the inside to the outside, which encodes the shortest path, first and therefore inserts three shortcuts.
Although this example has a lot of shortcuts, there are still a lot of vertices to expand in some cases.
In case every vertex of $G$ has a weight of $1$, and one wants to go from $v(1)$ to $v(5)$ the forward search will have to expand three to four vertices as in the upper first example.
\\
The third example contracts the middle vertex last.
At first it contracts the vertices right next to the middle vertex.
Therefore we have to insert shortcuts between $e(v(3)v(5))$ and $e(v(4), v(5))$.
Thus no matter what source-target-pair we are trying to find in this example, the forward and the backward search will have to expand at no more than one single vertex each.

\section{Vertex Importance}\label{sec:vertex_importance}

As discussed in section \ref{sec:not_contracted_last} and \ref{sec:linear_query} that are vertices that are more important than other vertices.
Contracting these vertices late is key to results in a efficient search lateron.


\subsection{Suitability of CCH}

As it is important to contract important vertices last, the advantage one gets in doing a CCH search over a simple dijkstra run depends on whether the base graph $G(V, E)$ has vertices which are more important than others.

A vertex $v \epsilon E$ is important if there are many shortest paths containing this very vertex.
Therefore if it is possible to calculate a small balanced separator on $G$, CCH will be able to show its whole advantage.
To dive deeper into this topic, see "Lower Bounds and Approximation Algorithms for Search Space Sizes in Contraction Hierarchies" \cite{BlumStorandt}.

\subsection{Metric dependent Importance}\label{sec:metric_dependent_importance}

As shown in section \ref{fig:not_contracted_last} and \ref{fig:linear_contraction}, taking only the edge difference $ED$ into account does not  necessarily lead to a proper order.
We decided to take the vertex importance calculation as proposed by Customization Contraction Hierarchies \cite{CCH}.
To every vertex we add the level property $l(v)$ which is initially set to $0$.
If a neighbor $w \epsilon N(v)$ is contracted, the level is set to $l(v) = max\{l(v)+1, l(w)\}$.
For every arc $a \epsilon A'$ we add a hop length to the arc $h(a)$.
The hop length equal the number of arcs.
This arc represents when fully unpacked.
Additionally, we denote as $A(v)$ the set of inserted arcs after the contraction of $v$ and $D(v)$ the set of removed arcs.
We calculate the importance $i(v)$ as follows:

\begin{equation}
    \label{eq:importance}
    i(v) = l(v) + \frac{|A(v)|}{|D(v)|} + \frac{\sum_{a \epsilon A(v)} h(a)}{\sum_{a \epsilon D(v)} h(a)} 
\end{equation}

Our tests show that this importance calculation results in a small increase regarding in the amount of shortcuts added, but the maximum vertex degree is smaller.
Which speeds up the contraction process towards the end.
Additionally the average search time decreases as the search space decreases.


% \section{Perfect Customization}
% 
% \begin{figure}
    % \centering
    % \input{assets/tikz/PerfectCustomization.tex}
    % \caption{Perfect Customization}
    % \label{fig:perfectCustomization}
% \end{figure}

\section{Update CCH}

\input{assets/pseudocode/update.tex}

The biggest advantage of CCH over CH is that it is easy to update without the need of changing the topological structure of the index graph.
This is the reason why CCH can be interesting for graph databases.
If an arcs $w(a(x, y))$ weight increases or decreases this can result in a weight change on arcs which connect vertices of higher rank than $x, y$.
We determine all arcs of the input graph $G$ that have been changed and push them to a priority queue.
The queue always returns the arc $a(x,y)$ with the lowest rank of the start vertex $x$.
If there are multiple it returns the one with the lowest rank of $y$ among the ones with the lowest rank of $x$.
Afterwards we determine the new weight of the arc using the lower triangles.
If there is a lower triangle which can be used as a pass through such that the arc weight in $G'$ does not change we only update the middle vertex.
If the weight of the arc has changed we assign the new weight to the arc.
Then we check all upper triangles, as shown in Figure \ref{fig:updateTriangles} of the arc $a(x,y)$. 
If there is an upper arc, denoted by $c$ in Figure \ref{fig:updateTriangles}, that is influenced by this change.
If it is influenced by this change we push it to the priority queue.
We do the same with all intermediate triangles.
\\
\begin{figure}
    \centering
    \input{assets/tikz/updateTriangles.tex}
    \caption{Update Triangles}
    \label{fig:updateTriangles}
\end{figure}

\subsection{Intermediate and Upper Triangles}

As the explanation of intermediate and upper triangles in Customization Contraction Hierarchies \cite{CCH} exists, but it is difficult to understand as kept quite short, we will describe it here in detail.

We define an arc as its start and end vertex $a(x,y)$, where the rank of $x$ is smaller as the rank $y$, $r(x) < r(y)$.
For every $a$ we want to construct triangles that involve a vertex $z$.
We assign the letter $b$ to arc between $x$ and $z$ and the letter $c$ to the arc between $y$ and $z$.

The motivation to construct these triangles is to find the shortest path from $y$ to $z$, to set the weight of $c$.
Therefore we have to resolve the equation to $c$
\begin{equation*}
    c = a + b
\end{equation*}

In the case of upper triangles we want to find a triangle for $x$ and $y$, such that middle vertex $z$ is of higher rank than both,  $r(x) < r(y) < r(z)$.
Therefore as shown in Figure \ref{fig:updateTriangles} results for the upper triangle:

\begin{align*}\label{eq:upper_triangle}
    c_\uparrow & = a_\downarrow + b_\uparrow    &  c_\downarrow & = a_\uparrow + b_\downarrow \\
    a(y, z) & = a(y, x) + a(x, z) & a(z, y) & = a(x, y) + a(z, x)
\end{align*}

In the case of intermediate triangles we want to find a triangle for $x$ and $y$, such that middle vertex $z$ is of higher rank than $x$ but of lower rank than $y$,  $r(x) < r(z) < r(y)$.
Therefore as shown in Figure \ref{fig:updateTriangles} results for the upper triangle:

\begin{align*}
    c_\uparrow & = a_\uparrow + b_\downarrow    &  c_\downarrow & = a_\downarrow + b_\uparrow \\
    a(y, z) & = a(y, x) + a(x, z) & a(z, y) & = a(x, y) + a(z, x)
\end{align*}
